<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 仙羡小站</title>
    <link>https://www.liyangjie.cn:4443/posts/</link>
    <description>Recent content in Posts on 仙羡小站</description>
    <image>
      <url>https://images.liyangjie.cn/image/SadBird.png</url>
      <link>https://images.liyangjie.cn/image/SadBird.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 29 Aug 2021 04:08:04 +0800</lastBuildDate><atom:link href="https://www.liyangjie.cn:4443/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HashMap基础</title>
      <link>https://www.liyangjie.cn:4443/posts/hashmap%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 29 Aug 2021 04:08:04 +0800</pubDate>
      
      <guid>https://www.liyangjie.cn:4443/posts/hashmap%E5%9F%BA%E7%A1%80/</guid>
      <description>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型，除了线程不安全外，基本上等同于HashTable，但是它允许null作为键和值。HashMap的Key要求是不可变类型的，因为如果是可变类型的Key，那么在使用过程中很有可能对Key对象进行了修改，导致哈希值发生变化，最终无法定位到HashMap中的元素。
Java8对HashMap进行了大修改，为了防止链表过大，影响插入和查找的效率(链表过大时，时间复杂度为O(n))，当链表元素的数量超过某个值时，自动将链表转换为红黑树(时间复杂度为O(log n)，注意这个地方有个坑，文章最后会介绍)
基础结构 简单来说，HashMap就是一个数组，数组中的每个位置被称做bin或者bucket(中文翻译为桶)，每个桶中都存放着一些Node(结点)。当一个桶中的Node数量较少的时候，使用链表对Node进行存储；当一个桶中的Node数量超过某个阈值的时候，就会将链表转换为红黑树，这个操作叫做treeify，即&amp;quot;树化&amp;quot;，注意树化操作还需要满足另外一个条件，就是数组的长度要超过MIN_TREEIFY_CAPACITY = 64，否则它的操作就不是树化，而是resize。同样，在resize操作的时候，也会判断一个桶中的Node数量是否会少于某个阈值，如果满足条件，则会重新将红黑树转换回链表，这个操作称为untreeify。
首先介绍几个重要的参数：
 capacity: 数组当前的最大长度，即为桶数量的最大值，最多存放多少个桶，这个数值在第一次添加元素的时候初始化为16。满足一定条件时，会扩容。这个长度必须是2的整数次方(16, 32, 64, 128 &amp;hellip;)，稍后在扩容章节会详细讲解其中的原因 loadFactor：负载因子，它搭配capacity使用，判断扩容条件，默认值为0.75 size：当前HashMap中的Node总数量 threshold：扩容阈值，它的值为loadFactor * capacity，重点：当size的值大于threshold值时，进行扩容  源码分析 table域-数组 这就是图中所示的那个数组，类型为Node：
1  transient Node&amp;lt;K,V&amp;gt;[] table;   再看看Node的内容，很明显，就是一个简单的链表结构:
1 2 3 4 5 6 7 8  static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; { final int hash; // 当前节点中Key的hash值，注意不是hashCode()的返回值，具体是什么会在扩容中介绍  final K key; // 键  V value; // 值  Node&amp;lt;K,V&amp;gt; next; // 下一个结点  ... }   当然还有其他类型的Node，如TreeNode，这里就不展示了</description>
    </item>
    
    <item>
      <title>Hello Hugo</title>
      <link>https://www.liyangjie.cn:4443/posts/hellohugo/</link>
      <pubDate>Sat, 28 Aug 2021 01:26:43 +0800</pubDate>
      
      <guid>https://www.liyangjie.cn:4443/posts/hellohugo/</guid>
      <description>以前自己折腾过各种平台的博客，WordPress、Hexo、Jekyll等，但最终都没有坚持把自己的博客搭建完成，不是这里效果不好，自己折腾不出来，然后一怒之下就弃了，要么就是工作出差，回来后就忘了，总之放弃是件简单的事情。
刚好处于工作真空期，想把一些平时学习的零碎内容整理一下，这次就坚持把这个博客完成了。这里就简单介绍下整个流程，及其中的一些坑和细节。篇幅较长，过程中可能有部分遗漏，轻喷。
首先是这次使用的博客平台，选择Hugo的理由很简单，因为没用过它，觉得新鲜，但实际上使用流程和搭建过程其实和以前接触过的静态站点生成框架大同小异。个人电脑环境是Win10，以前安装过scoop，因此安装方法如下：
1 2 3 4  scoop install hugo # 检查hubo是否安装完成 hugo version hugo v0.82.1-60618210 windows/amd64 BuildDate=2021-04-20T11:02:50Z VendorInfo=gohugoio   其他系统环境下安装方式见官网。
Hello Hugo 开始使用Hugo创建一个新站点hello-hugo (这个名字各位自己决定，只要当前工作目录下不存在非空的重名子目录):
1  hugo new site hello-hugo   执行成功后，Hugo会给出温馨的提示：
 Just a few more steps and you&amp;rsquo;re ready to go:
 Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the &amp;ldquo;hugo new theme &amp;rdquo; command.</description>
    </item>
    
  </channel>
</rss>
