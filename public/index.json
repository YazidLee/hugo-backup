[{"content":"HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型，除了线程不安全外，基本上等同于HashTable，但是它允许null作为键和值。HashMap的Key要求是不可变类型的，因为如果是可变类型的Key，那么在使用过程中很有可能对Key对象进行了修改，导致哈希值发生变化，最终无法定位到HashMap中的元素。\nJava8对HashMap进行了大修改，为了防止链表过大，影响插入和查找的效率(链表过大时，时间复杂度为O(n))，当链表元素的数量超过某个值时，自动将链表转换为红黑树(时间复杂度为O(log n)，注意这个地方有个坑，文章最后会介绍)\n基础结构 简单来说，HashMap就是一个数组，数组中的每个位置被称做bin或者bucket(中文翻译为桶)，每个桶中都存放着一些Node(结点)。当一个桶中的Node数量较少的时候，使用链表对Node进行存储；当一个桶中的Node数量超过某个阈值的时候，就会将链表转换为红黑树，这个操作叫做treeify，即\u0026quot;树化\u0026quot;，注意树化操作还需要满足另外一个条件，就是数组的长度要超过MIN_TREEIFY_CAPACITY = 64，否则它的操作就不是树化，而是resize。同样，在resize操作的时候，也会判断一个桶中的Node数量是否会少于某个阈值，如果满足条件，则会重新将红黑树转换回链表，这个操作称为untreeify。\n首先介绍几个重要的参数：\n capacity: 数组当前的最大长度，即为桶数量的最大值，最多存放多少个桶，这个数值在第一次添加元素的时候初始化为16。满足一定条件时，会扩容。这个长度必须是2的整数次方(16, 32, 64, 128 \u0026hellip;)，稍后在扩容章节会详细讲解其中的原因 loadFactor：负载因子，它搭配capacity使用，判断扩容条件，默认值为0.75 size：当前HashMap中的Node总数量 threshold：扩容阈值，它的值为loadFactor * capacity，重点：当size的值大于threshold值时，进行扩容  源码分析 table域-数组 这就是图中所示的那个数组，类型为Node：\n1  transient Node\u0026lt;K,V\u0026gt;[] table;   再看看Node的内容，很明显，就是一个简单的链表结构:\n1 2 3 4 5 6 7 8  static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; // 当前节点中Key的hash值，注意不是hashCode()的返回值，具体是什么会在扩容中介绍  final K key; // 键  V value; // 值  Node\u0026lt;K,V\u0026gt; next; // 下一个结点  ... }   当然还有其他类型的Node，如TreeNode，这里就不展示了\nput方法 当需要将元素存入HashMap时，我们使用V put(K, V)方法，它的作用是，若key已经存在，则用新的value替换原来的value；否则插入新的key和value，返回null(返回值为null也可以说明当前key在map中对应的值为null)。它的源码如下：\n1 2 3  public V put(K key, V value) { return putVal(hash(key), key, value, false, true); }   它调用了V putVal(int, K, V, boolean, boolean)方法，注意，这里还调用了一个hash方法，具体将在稍后的扩容中介绍，这里只需要明白它的作用是为了让Node分布更均匀。putVal方法的源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; // 1. 当数组为空或者数组长度为0的时候，延迟初始化  if ((tab = table) == null || (n = tab.length) == 0) // 此时，resize将使用16作为初始容量，创建初始数组，n = size = 16，threshold = 16 * 0.75 = 12  n = (tab = resize()).length; // 2. 将hash映射到数组长度内，得到索引值，并判断tab在该处是否已经有Node  if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) // 若没有Node，则表明此次插入的Node为tab[i]这个桶上的第一个Node，直接将该Node赋值给tab[i]  tab[i] = newNode(hash, key, value, null); // 3. 数组不为空，且当前桶处已有其他Node  else { Node\u0026lt;K,V\u0026gt; e; K k; // 判断待插入的key与桶中的第一个Node的key是否相等，若相等，则稍后直接覆盖  if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; // 如果是红黑树结构，则进行红黑树的put操作  else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); // 如果是链表结构  else { // 遍历链表，直到找到元素，或者到达表尾  for (int binCount = 0; ; ++binCount) { // 到达表尾，没有找到与传入的key相等(hash和equals判断)的Node，则插入新结点  if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 若插入新结点后，当前桶中的链表结点数超过了8个，则转换为红黑树  if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } // 在链表中找到了与传入key相等的Node，则直接退出遍历，并在稍后将值直接覆盖  if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } // 4. e不为空表示HashMap中已有相同key的Node，直接将旧值替换成新值  if (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 返回旧值  return oldValue; } } // 修改后，这个值递增，确保fast-fail机制  ++modCount; // 5. size自增，若此时size的值大于threshold，则进行扩容  if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; }   着重介绍其中几个关键流程(以下编号与代码注释中的编号对应)：\n 判断当前的数组是否为空(或长度为0)，若满足条件，则说明当前put的Node为当前HashMap对象中的第一个Node，就调用resize()方法创建一个数组。在之前的Java版本中，这个创建数组的操作都是在构造函数中完成的，这就导致了，即使不往HashMap里存东西，它也会占据内存空间。这里延迟到了添加第一个元素的时候，确保即使new了一个HashMap，且不往里面存东西，它也不会占据额外的内存空间。 这里先将一个hash值(32位int值)映射到数组的索引范围内，常见的做法是对素数取余，但这里利用位运算进行(n - 1) \u0026amp; hash(稍后再介绍这个操作)，这里将这个索引值记为index。随后判断这个索引位置上的桶是否已经有Node存在，若没有，则表示当前插入Node为该桶中的第一个Node，直接进行赋值操作tab[index] = newNode... 若index处的桶中已有Node，则需要进一步的判断：  若index处桶中的第一个Node的key就与待插入的key相等(hash和equals判断)，则不用进行后面的判断，准备进行直接的值覆盖 否则，判断当前Node的类型，若是TreeNode，表明它是红黑树，则进行红黑树的put操作 否则，表示当前Node为普通链表类型，对当前的链表进行遍历操作。若找到了key相等的Node，就break结束遍历，准备直接覆盖值；若找不到，则在链表尾插入相应的新Node，并判断当前链表的长度，若超过了阈值TREEIFY_THRESHOLD(8)，则将链表树化，转化成红黑树结构   在上述的插入过程中，若找到了key与待插入key相等的Node，则直接用新值对该Node的值进行覆盖，并直接返回旧值，结束整个插入过程 若没有找到key与待插入key相等的Node，则表明进行了插入操作，此时Node的总数量增加，即size自增。此时判断size的值是否大于扩容域值，若满足条件，则进行扩容，这个操作将在下面进行具体介绍。  值得注意的一点是，treeifyBin这个将列表转换为红黑树的方法，它在数组的总容量较小的情况下并不会真正将链表转换为红黑树，而是先进行resize扩容操作，具体代码如下：可以看到，在length小于MIN_TREEIFY_CAPACITY(64)的情况下，它直接调用了resize()方法，并没有直接将链表转换为树\n1 2 3 4 5 6 7 8  final void treeifyBin(Node\u0026lt;K,V\u0026gt;[] tab, int hash) { int n, index; Node\u0026lt;K,V\u0026gt; e; if (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY) resize(); else if (...) { ... } }   扩容 扩容(resize) 就是重新计算容量、扩大数组容量以及将已有元素重新放置。若向HashMap对象里不停的添加元素，而HashMap对象内部的数组存储的元素达到一定数量时，就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的、更大的数组代替已有的容量小的数组。\n当然，“能够装入更多的元素”这个说法不太严谨，其实就算不扩容，理论上也能不停地加入元素，因为链表和红黑树都能无限扩展： HashMap的查询和插入效率很高，理论上能达到常数级别，但当每个桶中的Node都非常多，查询效率和插入效率就会大打折扣，每次查询或者插入需要比较的次数迅速增加，链表会退化为O(n)(JDK8之前)，而红黑树也需要O(logn)。因此，当Node过多，可以通过扩容的方式，将集中在同若干个桶中的Node分散到更多的桶中，用空间换取时间\n(length - 1) \u0026amp; hash 关于这个容量，首先要介绍一个重要的结论，它的值必须是一个2的正整数次幂。\n 当使用默认的构造方法(无参数)创建HashMap时，默认的初始容量为16(如上面所说，是在插入第一个元素时分配的)； 如果使用的是带参数的构造方法(带int值的)，那么就会先计算大于等于该值的、最小的一个2的正整数次幂(比如传入的int值为17，2^4 \u0026lt; 17 \u0026lt; 2^5，则其初始容量为2^5 = 32)，同样是延迟到第一次put时才创建数组。下面是相关的代码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * The default initial capacity - MUST be a power of two. 默认初始容量-必须为2的幂 */ static final int DEFAULT_INITIAL_CAPACITY = 1 \u0026lt;\u0026lt; 4; // aka 16 ... public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;Illegal initial capacity: \u0026#34; + initialCapacity); if (initialCapacity \u0026gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor \u0026lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\u0026#34;Illegal load factor: \u0026#34; + loadFactor); this.loadFactor = loadFactor; // tableSizeFor()方法将返回大于等于initialCapacity的2的整数幂，并将这个返回值赋值给threshold  // 在第一次调用resize()方法时，会将这个threshold作为初始容量创建数组，这个地方用法比较特殊  // 后续操作中threshold将一直作为判断是否扩容的标准，它的值为capacity*loadFactor  this.threshold = tableSizeFor(initialCapacity); }   所以为什么一定要是2的正整数次幂呢？这里又需要回顾上面putVal中，注释编号为2的代码处：\n1 2 3 4  ... n = tab.length ... ... if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) ...   上述代码中i = (n - 1) \u0026amp; hash很明显是在获取哈希值为hash的key所对应的数组索引(替代求余操作)，其中的n值为数组的length，所以这个索引实际上就是(length - 1) \u0026amp; hash。 将两个int类型的正整数进行按位与计算，结果不会超过两个数中的最小者，所以上面的操作结果不会超过length - 1，即结果范围为：[0, length - 1]，这就将hash映射到了数组的索引中。如下图所示，假定容量为64：\n随之而来的一个问题是，那为什么一定要是2的整数幂呢？任意一个容量(randomLength - 1) \u0026amp; hash进行按位与不也可以得到不超过容量的索引吗？现在假设不是2的整数次幂，比如62，如下图所示。绿色位置的值为0，此时进行按位与操作，不管hash中的红色部分值是0还是1，计算结果中相应位置上的值都是0。这意味着，计算后的索引结果中，不能取得*[0, 61]*这个区间内的所有值，有些值是不可能得到的，比如2, 3等等(因为结果的第二位是0，所以不可能是2和3)，也即HashMap中会有许多桶始终为空，造成了链表或者红黑树的高度增加，效率降低。因此，(length - 1)的二进制表示需要全部为1，也即length必须是2的整数幂。\nint hash(Object)方法 在put方法介绍时，还留了一个坑，那就是int hash(Object)方法，有了刚介绍的知识，就可以简单了解一下了：\n1 2 3 4 5 6 7 8 9 10  // put方法调用了putVal方法，putVal方法的第一个参数使用了hash方法，因此实际上传入putVal方法的hash值其实是经过处理的hashCode() public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } // hash方法 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); }   putVal方法的第一个参数使用了int hash(Object)方法，因此实际上传入putVal方法的hash值其实是经过再处理的哈希值，而不是直接使用我们代码中编写的hashCode()。这个方法是对程序员重写的hashCode()的一种优化，因为程序员编写的hashCode()目的是尽量让返回值在int(32位)范围内尽可能不同。然而，根据上一部分的分析，在数组容量length较小时，我们往往只使用到了低位的hash值，高位的hash值被忽略(此时length - 1的二进制高位均为0)，这很可能导致冲突较多。因此，int hash(Object)方法让高位与低位进行了一次异或运算，保证高位的值也能够体现在hash值中，能够有效减少冲突。\nresize()方法 啥都不说，先上源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  final Node\u0026lt;K,V\u0026gt;[] resize() { // 扩容前的数组  Node\u0026lt;K,V\u0026gt;[] oldTab = table; // 扩容前的容量，因为这个方法在第一次put的时候也会被调用，它需要考虑到为null的情况  int oldCap = (oldTab == null) ? 0 : oldTab.length; // 扩容前的扩容阈值threshold  int oldThr = threshold; // 扩容后的新容量和新阈值  int newCap, newThr = 0; // 如果旧的容量大于0，表示不是第一次put元素，HashMap中已有数据  if (oldCap \u0026gt; 0) { if (oldCap \u0026gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 1. 容量翻倍  else if ((newCap = oldCap \u0026lt;\u0026lt; 1) \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; // 如果旧容量比16小，则使用后面的方式计算新扩容阈值  oldCap \u0026gt;= DEFAULT_INITIAL_CAPACITY) // 同时，新的容量阈值为旧容量阈值的两倍(因为新的容量翻倍了)  newThr = oldThr \u0026lt;\u0026lt; 1; // double threshold  } // 上文提到过，当使用带int参数的HaspMap构造方法时，就在这个地方将threshold作为初始化数组的大小  // 注意此处没有指定newThr，则时候稍后的方法进行计算  else if (oldThr \u0026gt; 0) // initial capacity was placed in threshold  newCap = oldThr; else { // zero initial threshold signifies using defaults  // 同样在上文提到过，当使用无参数的HashMap构造方法时，就在这里指定默认的初始数组大小  newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 针对上文中没有计算newThr的情况，统一在这进行计算  if (newThr == 0) { // newThr的值为capacity * loadFactor  float ft = (float)newCap * loadFactor; newThr = (newCap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } // 将计算后的新阈值赋给threshold，表示扩容后的阈值  threshold = newThr; // 2. 创建大小为新容量的数组  @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] newTab = (Node\u0026lt;K,V\u0026gt;[])new Node[newCap]; // 将HashMap中的数组替换为新数组  table = newTab; // 将旧数组中的Node往新数组中搬  if (oldTab != null) { // 遍历旧数组中的各个桶  for (int j = 0; j \u0026lt; oldCap; ++j) { Node\u0026lt;K,V\u0026gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; // 如果桶中只有一个Node，则使用(length - 1) \u0026amp; hash的方法，直接将这个Node存到新数组的相应位置  if (e.next == null) newTab[e.hash \u0026amp; (newCap - 1)] = e; // 如果是红黑树，则进行红黑树相关操作  else if (e instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)e).split(this, newTab, j, oldCap); // 3. 如果是链表，则遍历链表中的所有结点，确定其在新数组中的位置  else { // 4. preserve order  // 5. 将旧桶中的链表结点分成两类，分别组成两个链表，然后分别插入到新数组的特定桶中  Node\u0026lt;K,V\u0026gt; loHead = null, loTail = null; // 低位置的链表，记为lo  Node\u0026lt;K,V\u0026gt; hiHead = null, hiTail = null; // 高位置的链表，记为hi  Node\u0026lt;K,V\u0026gt; next; do { next = e.next; // 骚操作，表示e所指向的结点在新数组中的下标和旧数组中的下标相同，把这些Node放到lo链表中，原因还是因为数组容量为2的整数幂  if ((e.hash \u0026amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 否则，表示e所指向的结点在新数组中的下标是旧数组中下标的2倍，把这些Node放到hi链表中  else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 分别将两个链表插入到低位和高位桶中  if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; }   相当复杂，还是和前面的putVal一样，列举几个关键点进行分析：\n  这里不讨论数组为空的情况，假设现在HashMap中已经有许多Node了，并且在插入完成某个新的Node后，触发了扩容(忘记了?快回头去看看putVal方法的第5点)，此时，把新的容量和新的扩容阈值都设为原来的2倍\n  随后，创建一个大小为新容量的数组，并将HashMap中的table重新赋值(这个也忘记了?请回到源码分析的开头部分)，这时候就已经完成了容量的翻倍，但旧数组中的Node都还没搬过来\n  由于红黑树较为复杂 (我还不会) ，这里只分析链表的情况\n  请注意这个地方有个很显眼的 preserve order ，这个是JDK开发人员的注释，为什么要特别加这么一条注释呢？其实是因为这个地方在Java8之前有个不算坑的坑，这里就稍微说明一下：由于Java8之前，采用的是链表的头插法，因此在扩容过程中，有可能导致链表结点之间的顺序改变，这在一般情况下并不是什么问题，但在多线程环境下，有概率出现循环链表，从而出现死循环的情况。有人就把这个问题反馈给了JDK开发人员，但是，HashMap的说明中明确指出了，HashMap是线程不安全的，所以当时也并没有对这个问题进行解决(这纯粹就是使用者的锅)。但是到了Java8，这个问题被重写HashMap的JDK开发人员顺手给解决了，他特地在这标注了一个 preserve order，表示已经解决了那个坑，有兴趣的话可以访问这个链接JAVA HASHMAP的死循环\n  这个位置就是要开始将旧数组中的链表搬到新数组的桶中了。与Java8之前的方法不同，在这段代码中，没有对每个Node重新进行hash值的计算(为了在新的数组中确定Node的索引值)，而是使用了(e.hash \u0026amp; oldCap) == 0这么一个熟悉的条件判断进行索引位置的确定。啧，怎么又是个按位与操作？之前我们使用过hash \u0026amp; (length - 1)确定索引值，而这里的(e.hash \u0026amp; oldCap) == 0又是个什么操作？仔细分析，不难发现，oldCap表示扩容前的容量，是一个2的整数幂的值，所以它的二进制表示为某个特定位上的值为1，其余位置全是0，用它和结点的hash值进行按位与，就是判断结点的hash值在那个对应的特定位置上是否为0。那这又有什么用呢？结合下面图片进行分析： 图中，上面两个二进制数表示的是扩容前的某个结的hash值和oldCap - 1；下面两个二进制数表示的是扩容后的同一个结点的hash值和newCap - 1。通过观察，由于扩容时容量加倍，使得newCap - 1比oldCap - 1多出了一位1(绿色的部分)，因此进行hash \u0026amp; (length - 1)时，hash中参与计算的位也多了一位(红色的部分)。这个位置hash的值不是0就是1，也就是说，hash \u0026amp; (newCap - 1)和hash \u0026amp; (oldCap - 1)的结果就差在这一位上(因为是计算同一个结点在新老数组中的索引位置，参与计算的hash值是相同的，而且容量减1的值在各个位上都是1)。所以我们就可以做出一个判断：\n 当红色部分的值为0时，新数组中的索引值newIndex和老数组中的索引值相同，即newIndex = oldIndex 当红色部分的值为1时，新数组中的索引值newIndex是老数组中的索引值的2倍，同时，由于新老数组的容量都刚好是2的整数幂，因此可以写成newIndex = oldIndex + oldCap的形式  有了这些分析，我们现在就可以知道，(e.hash \u0026amp; oldCap) == 0这个操作判断的就是新增位上(红色的部分)hash值的情况(0或1)。随后，把所有判断结果为0的结点连接成一个链表lo，把所有判断结果为1的结点连接成一个链表hi。最后，把lo放到新数组中索引与老数组相同的位置，而hi则被放入[oldIndex + oldCap]的位置。\n  HashMap和Comparable 最后，还有一个坑要填(即使实际开发中并不会遇到)。虽然对于红黑树的了解不算深入，但至少知道它是个动态平衡的二叉查找树，比大小是它核心的一个操作。随之而来的一个问题就是，HashMap不像TreeMap要求Key实现Comparable或者构造时提供Comparator，它对于Key没有这方面的限制，那它内部是通过什么来进行比较呢？下面先进行一个实验：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  class TestKey { private String id; private int number; public TestKey(String id, int number) { this.id = id; this.number = number; } /** * 故意写个冲突的hashCode * @return 返回固定的hashCode */ @Override public int hashCode() { return 5; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; TestKey testKey = (TestKey) o; return number == testKey.number \u0026amp;\u0026amp; id.equals(testKey.id); } } public class HashMapDemo { private static final int COUNT = 500_000; public static void main(String[] args) { HashMap\u0026lt;TestKey, Integer\u0026gt; testMap = new HashMap\u0026lt;\u0026gt;(); Integer testValue = -1; TestKey key = null; long startTime = System.currentTimeMillis(); for (int i = 0; i \u0026lt; COUNT; i++) { key = new TestKey(\u0026#34;test\u0026#34;, i); testMap.put(key, i); } long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;插入耗时:\u0026#34; + (endTime - startTime)); } }   执行结果：\n1  插入耗时:4875921   上述代码中的TestKey作为HashMap的键，且刻意让它的hashCode()方法返回固定值，在put的时候不断产生冲突。main方法中进行了50万次put，花了1个多小时才完成。\n现在修改TestKey类，让它实现Comparable接口，其他代码不变：\n1 2 3 4 5 6 7  class TestKey implements Comparable\u0026lt;TestKey\u0026gt; { ... @Override public int compareTo(TestKey o) { return number - o.number; } }   再次执行，看看结果：\n1  插入耗时:155   可以看到，其他操作都不变，仅仅多实现了一个Comparable，put的执行时间就显著缩短了。由于这么多数据都在同一个桶中，它们的结构肯定是红黑树，因此，直接分析putTreeVal方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  final TreeNode\u0026lt;K,V\u0026gt; putTreeVal(HashMap\u0026lt;K,V\u0026gt; map, Node\u0026lt;K,V\u0026gt;[] tab, int h, K k, V v) { Class\u0026lt;?\u0026gt; kc = null; boolean searched = false; TreeNode\u0026lt;K,V\u0026gt; root = (parent != null) ? root() : this; for (TreeNode\u0026lt;K,V\u0026gt; p = root;;) { int dir, ph; K pk; if ((ph = p.hash) \u0026gt; h) dir = -1; else if (ph \u0026lt; h) dir = 1; else if ((pk = p.key) == k || (k != null \u0026amp;\u0026amp; k.equals(pk))) return p; else if ((kc == null \u0026amp;\u0026amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) { if (!searched) { TreeNode\u0026lt;K,V\u0026gt; q, ch; searched = true; if (((ch = p.left) != null \u0026amp;\u0026amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null \u0026amp;\u0026amp; (q = ch.find(h, k, kc)) != null)) return q; } dir = tieBreakOrder(k, pk); } ... } } }   能够发现，在红黑树中插入数据时，先判断hash值，当hash值相等，且equals判断也相等，则会判断是否为Comparable；若Key实现了Comparable，则直接使用compareTo方法进行大小判断；若连Comparable都没实现(或者compareTo方法判断为相等时)，则会调用tieBreakOrder方法，这个方法中使用System.identityHashCode进一步分析。对于50w个数据来说，System.identityHashCode调用相当耗时，从上面的例子中可以看到，花了1个多小时。\n因此，虽然Java8对HashMap进行了优化，使过长的链表优化成红黑树，但如果Key的hashCode算法不佳，且Key没有实现Comparable接口，那么仍然有可能引发很糟糕的后果。在HashMap源码中，编写者有这么一段话：\n If neither of these apply, we may waste about a factor of two in time and space compared to taking no precautions. But the only known cases stem from poor user programming practices that are already so slow that this makes little difference.\n 大概意思是：如果两者都不满足(指良好的hashCode方法和实现Comparable接口)，那么HashMap的新实现(红黑树)会浪费两倍的空间和时间。但是这种极端的情况是由开发者不良的编程实现引起的，其实用什么实现(链表或者红黑树)已经没区别了。\n","permalink":"https://www.liyangjie.cn:4443/posts/hashmap%E5%9F%BA%E7%A1%80/","summary":"HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型，除了线程不安全外，基本上等同于HashTable，但是它允许null作为键和值。HashMap的Key要求是不可变类型的，因为如果是可变类型的Key，那么在使用过程中很有可能对Key对象进行了修改，导致哈希值发生变化，最终无法定位到HashMap中的元素。\nJava8对HashMap进行了大修改，为了防止链表过大，影响插入和查找的效率(链表过大时，时间复杂度为O(n))，当链表元素的数量超过某个值时，自动将链表转换为红黑树(时间复杂度为O(log n)，注意这个地方有个坑，文章最后会介绍)\n基础结构 简单来说，HashMap就是一个数组，数组中的每个位置被称做bin或者bucket(中文翻译为桶)，每个桶中都存放着一些Node(结点)。当一个桶中的Node数量较少的时候，使用链表对Node进行存储；当一个桶中的Node数量超过某个阈值的时候，就会将链表转换为红黑树，这个操作叫做treeify，即\u0026quot;树化\u0026quot;，注意树化操作还需要满足另外一个条件，就是数组的长度要超过MIN_TREEIFY_CAPACITY = 64，否则它的操作就不是树化，而是resize。同样，在resize操作的时候，也会判断一个桶中的Node数量是否会少于某个阈值，如果满足条件，则会重新将红黑树转换回链表，这个操作称为untreeify。\n首先介绍几个重要的参数：\n capacity: 数组当前的最大长度，即为桶数量的最大值，最多存放多少个桶，这个数值在第一次添加元素的时候初始化为16。满足一定条件时，会扩容。这个长度必须是2的整数次方(16, 32, 64, 128 \u0026hellip;)，稍后在扩容章节会详细讲解其中的原因 loadFactor：负载因子，它搭配capacity使用，判断扩容条件，默认值为0.75 size：当前HashMap中的Node总数量 threshold：扩容阈值，它的值为loadFactor * capacity，重点：当size的值大于threshold值时，进行扩容  源码分析 table域-数组 这就是图中所示的那个数组，类型为Node：\n1  transient Node\u0026lt;K,V\u0026gt;[] table;   再看看Node的内容，很明显，就是一个简单的链表结构:\n1 2 3 4 5 6 7 8  static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; // 当前节点中Key的hash值，注意不是hashCode()的返回值，具体是什么会在扩容中介绍  final K key; // 键  V value; // 值  Node\u0026lt;K,V\u0026gt; next; // 下一个结点  ... }   当然还有其他类型的Node，如TreeNode，这里就不展示了","title":"HashMap基础"},{"content":"以前自己折腾过各种平台的博客，WordPress、Hexo、Jekyll等，但最终都没有坚持把自己的博客搭建完成，不是这里效果不好，自己折腾不出来，然后一怒之下就弃了，要么就是工作出差，回来后就忘了，总之放弃是件简单的事情。\n刚好处于工作真空期，想把一些平时学习的零碎内容整理一下，这次就坚持把这个博客完成了。这里就简单介绍下整个流程，及其中的一些坑和细节。篇幅较长，过程中可能有部分遗漏，轻喷。\n首先是这次使用的博客平台，选择Hugo的理由很简单，因为没用过它，觉得新鲜，但实际上使用流程和搭建过程其实和以前接触过的静态站点生成框架大同小异。个人电脑环境是Win10，以前安装过scoop，因此安装方法如下：\n1 2 3 4  scoop install hugo # 检查hubo是否安装完成 hugo version hugo v0.82.1-60618210 windows/amd64 BuildDate=2021-04-20T11:02:50Z VendorInfo=gohugoio   其他系统环境下安装方式见官网。\nHello Hugo 开始使用Hugo创建一个新站点hello-hugo (这个名字各位自己决定，只要当前工作目录下不存在非空的重名子目录):\n1  hugo new site hello-hugo   执行成功后，Hugo会给出温馨的提示：\n Just a few more steps and you\u0026rsquo;re ready to go:\n Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026ldquo;hugo new theme \u0026rdquo; command. Perhaps you want to add some content. You can add single files with \u0026ldquo;hugo new \u0026lt;FILENAME\u0026gt;.\u0026rdquo;. Start the built-in live server via \u0026ldquo;hugo server\u0026rdquo;.   等会我们就按这个顺序完成站点的创建。先看看执行完hugo new site命令后，Hugo为我们做了什么。\n工作目录内容 进入hello-hugo目录，Hugo生成的内容如下图所示：\n这些大致作用如下：\n archetypes：存放博客的模板，默认提供了一个default.md作为所有博客的模板 content：顾名思义，存放我们所有的博客正文 data：存放一些数据，如xml、json等 layouts：与博客页面布局相关的内容，如博客网页中的header、footer等 static：存放静态资源，如图标、图片等 themes：主题相关 config.toml：站点、主题等相关内容的配置文件，它支持yaml、toml和json格式，后续将会一直和这个文件打交道  除了上述几个目录之外，Hugo还规定了许多其他目录用于提供不同的作用，如assets、i18n等。\n主题下载和使用 根据提示，要使用Hugo，我们必须先下载主题(或自己创建主题)，这里我选择自己比较喜欢的PaperMod。\n先到PaperMod Giuhub，根据官方文档的提示进行主题的下载。PaperMod官方提供了3种下载方式，这里推荐第二种，以git submodule的方式下载。\n进入hello-hugo目录，分别执行如下命令：\n1 2 3  git init # 将hello-hugo初始化为git仓库 git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 # 将PaperMod作为hello-hugo依赖的submodule git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically)   完成后，会在themes目录下会多出一个PaperMod目录：\n可以发现，这个目录的结构与我们自己的hello-hugo目录十分相似，各目录的作用也基本一致。\n随后，为了使用这个主题，需要在config.toml中激活，为了保持和PaperMod一致，这里将这个文件的后缀修改为.yml，在config.yml中配置如下：\n1 2 3 4  baseURL: \u0026#34;http://example.org/\u0026#34; languageCode: \u0026#34;en-us\u0026#34; title: \u0026#34;Hello Hugo\u0026#34; theme: \u0026#34;PaperMod\u0026#34;   这时候主题已经激活了，我们先往博客中添加一篇文章，首先创建名为posts的section：\n1  hugo new section posts   完成后，在content目录下创建了一个名为posts的目录，这就是我们存放文章的目录。随后创建一篇文章：\n1 2  hugo new posts/HelloHugo1.md hugo new posts/HelloHugo2.md   进入posts目录，编辑两个.md文件，写点内容：\n1 2 3 4 5 6 7 8  --- title: \u0026#34;HelloHugo1\u0026#34; date: 2021-08-29T21:13:55+08:00 draft: false --- # Hello, Hugo1 你好，雨果   1 2 3 4 5 6 7 8  --- title: \u0026#34;HelloHugo2\u0026#34; date: 2021-08-29T21:18:38+08:00 draft: false --- # Hello, Hugo2 你好，雨果   文件头部为Hugo自动添加的内容，它来自archetypes目录中的default.md模板，注意draft属性，默认值为true表示文章处于草稿状态，该状态下的文档不会参与站点的生成，也就是说网站上没有草稿文章，所以此处需要将其先设置为false。\n现在可以使用Hugo内置的Server预览一下成果(工作目录必须在hugo-hello)：\n1  hugo server   😭emmmmmmm，怎么说呢，有成果出来了，但是效果好像不太好，别急，接下来我们慢慢完善。\n主题配置完善 基本上每个主题都会提供相应的demo，PaperMod的demo如下：\n我们现在就以它为目标进行改进。\n学习的最快方式就是模仿，所以我们直接到demo的github(注意是PaperMod demo的github，而不是PaperMod的github)上把config.yml抄过来。\n可以注意到前几行配置我们就新增了一条paginate: 5，其他保持不变，从enableInlineShortcodes开始都是来自demo的配置。\nlanguages、archives、search 在demo的languages的配置段中，有en、fr和fa3块，它们使用的主题Mode不同，且包含部分国际化的配置，我们暂时只需要使用en，可以将fr和fa注释或者直接删除掉。\nen下最重要的就是menu配置了，它表示了导航栏显示的内容，demo中提供了最常用的4项，即Archive、Search、Tags及Categories。每项中包含一个weight，表示它们在导航栏中的显示顺序，越小越靠前。\n根据PaperMod官方使用文档的描述，要使用Archive和Search，需要进行以下操作：\n  在content下增加archives.md文件，具体位置如下：\n1 2 3 4 5 6 7 8  . ├── config.yml ├── content/ │ ├── archives.md \u0026lt;--- Create archive.md here │ └── posts/ ├── static/ └── themes/ └── PaperMod/   archives.md内容为：\n1 2 3 4 5 6  --- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; url: \u0026#34;/archives/\u0026#34; summary: archives ---     在config.yml中新增如下内容，demo中已经配置好的，这步可以跳过：\n1 2 3 4 5  outputs: home: - HTML - RSS - JSON # is necessary   同样在content新增一个search.md，内容如下：\n1 2 3 4 5 6 7  --- title: \u0026#34;Search\u0026#34; # in any language you want layout: \u0026#34;search\u0026#34; # is necessary # url: \u0026#34;/archive\u0026#34; # description: \u0026#34;Description for Search\u0026#34; summary: \u0026#34;search\u0026#34; ---     完成上述操作后，再看看效果：\n😏像那么回事了吧！\nparams params包括了PaperMod主题中的重要配置参数，下面举几个例子来进行说明，其他详细配置用法可以参照官方说明，也可以自己试试，大部分配置都是见名知意的。\n主题样式相关   defaultTheme：设置白色主题或者黑色主题，设置为auto则表示跟随浏览器\n  disableThemeToggle:：是否允许白色主题和黑色主题进行手动切换，设置成true则在网页顶部提供切换按钮\n  homeInfoParams、socialIcons：这两参数配置的首页显示的内容，修改内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12  homeInfoParams: Title: \u0026#34;Hello Hugo\u0026#34; Content: \u0026gt;Lorem ipsum dolor sit amet, consectetuer adipiscing elit, - sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. socialIcons: - name: github url: \u0026#34;https://github.com/adityatelange/hugo-PaperMod\u0026#34; - name: telegram url: \u0026#34;https://ko-fi.com/adityatelange\u0026#34; - name: RsS url: \u0026#34;index.xml\u0026#34;   结果如下：\n关于socialIcons参数，PaperMod官网给出了具体的参照表。\n  网站图标相关参数如下，可以指定网络路径或本地路径：\n1 2 3 4 5 6  assets: favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34;     博客内容相关   ShowShareButtons是否显示分享博客按钮，具体按钮的设定仍可参照PaperMod官网\n  ShowReadingTime是否显示文章阅读时间\n  ShowBreadCrumbs 是否显示面包屑\n  ShowCodeCopyButtons是否显示代码复制按钮\n  ShowToc是否显示文章目录\n  博客封面相关：\n1 2 3 4 5  cover: responsiveImages: false # 仅仅用在Page Bundle情况下，此处不讨论 hidden: false # hide everywhere but not in structured data 是否在下面两种情况下显示 hiddenInList: false # hide on list pages and home 是否在列表视图中显示 hiddenInSingle: false # hide on single page 是否在单页视图中显示   为了测试，我将后面3个配置项全部设置为true，并在两篇测试博客中修改front matter(就是博客最上方的数据):\n1 2 3 4 5 6 7 8 9  --- title: \u0026#34;HelloHugo1\u0026#34; date: 2021-08-29T21:13:55+08:00 draft: cover: image: \u0026#34;https://images.liyangjie.cn/Sekiro_01.jpg\u0026#34; alt: \u0026#34;替换文本\u0026#34; caption: \u0026#34;封面标题\u0026#34; ---   1 2 3 4 5 6 7 8 9  --- title: \u0026#34;HelloHugo2\u0026#34; date: 2021-08-29T21:18:38+08:00 draft: cover: image: \u0026#34;https://images.liyangjie.cn/Sekiro_02.jpg\u0026#34; alt: \u0026#34;替换文本\u0026#34; caption: \u0026#34;封面标题\u0026#34; ---   再来看看结果，是不是有点味道了：\n  分类相关 默认情况下，Hugo支持categories、tags两个级别的分类，通过配置新增更多的分类：\n1 2 3 4  taxonomies: category: categories tag: tags series: series   这里又配置了一个series的分类维度，可以在博客的front matter中使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  --- title: \u0026#34;HelloHugo1\u0026#34; date: 2021-08-29T21:13:55+08:00 draft: cover: image: \u0026#34;https://images.liyangjie.cn/Sekiro_01.jpg\u0026#34; alt: \u0026#34;替换文本\u0026#34; caption: \u0026#34;封面标题\u0026#34; categories: - Hugo tags: - Hugo series: - Hugo ---   这时候再进入网站的Tags导航项，就可以看到我们的标签和数量了：\n代码样式相关 PaperMod0配置代码显示样式如下，这里是我个人使用的配置：\n1 2 3 4 5 6 7 8 9 10 11  markup: goldmark: renderer: unsafe: true highlight: # anchorLineNos: true codeFences: true guessSyntax: true lineNos: true # noClasses: false style: monokai   将lineNos设置为true后，会产生bug，官方提供了解决方案：\n在hugo-hello，即工作目录下创建assets/css/custom.css文件，在文件中添加如下内容即可：\n1 2 3  .chroma { background-color: unset; }   现在往第一篇博客中添加一个代码段如下：\n1 2 3 4 5  ```java public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } ```   显示效果如图：\n增加评论区 我选择使用的是Valine，前置工作需要在LeanCloud上注册并创建应用，获取到相关的AppID和AppKey，具体流程请参照Valine官方网站。\n获取到这两个参数后，根据PaperMod官方文档的指示，创建layouts/partials/comments.html文件，partials路径不存在就自己创建，在文件中添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11  {{ $valinejs := resources.Get \u0026#34;js/Valine.min.js\u0026#34; }} \u0026lt;script src=\u0026#39;{{ $valinejs.RelPermalink }}\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;vcomments\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Valine({ el: \u0026#39;#vcomments\u0026#39;, appId: \u0026#39;这里是你的AppID\u0026#39;, appKey: \u0026#39;这里是你的AppKey\u0026#39;, placeholder: \u0026#39;来都来了，说两句~\u0026#39; }) \u0026lt;/script\u0026gt;   随后创建assets/js/Valine.min.js，将CDN中的内容全部拷贝到该文件中，保存。\n在config.yml配置文件中设置评论开启即可，直接查找comments就可以定位到该配置的位置了，默认是关闭状态：\n1  comments: true   最后来看看效果：\n配置入门大致就先讲到这里，下面简单介绍下我的站点部署方式。\n部署相关 Hugo与Hexo类似，提供了直接部署为Github Pages的方式，比较简单，请直接移步到官网。\n但我自己想折腾折腾，以前使用Hexo的时候在自己的云主机上进行了部署，当时域名整了好久(国内域名，需要备案)，等域名搞定，黄花菜都凉了，所以这次刚好手头还保留着一台云主机，域名也一直在续费，就借此机会再折腾折腾。\n准备工作 软件环境准备  云主机的操作系统为Debian 4.19.37-5+deb10u2 (2019-08-08) x86_64 GNU/Linux，其他发行版也都可以 静态资源服务器nginx/1.20.1 git/2.20.1  域名、证书准备   准备好一个域名，并DNS解析至云服务器，国内需要走备案审批流程，国外域名则不需要，大家自行斟酌\n  证书可选择各平台免费的DV证书，这里我随便找了一个腾讯云的SSL证书，品牌为TrustAsia，有效期一年\n  git仓库及钩子 准备充分后，先在服务器上新建一个名为git的用户专门用于git同步：\n1  sudo adduser git   为了安全，修改分配给该用户的shell环境，编辑/etc/passwd文件，在末尾可以找到我们新增的git用户，修改后效果如下：\n1 2 3  ... ... # 修改前为 git❌1001:1001:,,,:/home/git:/bin/bash git❌1001:1001:,,,:/home/git:/usr/bin/git-shell   在自己的**客户端(Win10)**准备好SSH公钥，具体流程可以参照Github教程。完成后，将公钥拷贝至服务器/home/git/.ssh/authorized_keys文件里，该文件中若有其他公钥，则在末尾换行后添加即可。\n在适当目录创建hugo的裸仓库：\n1  git init --bare hello-hugo.git   将该目录授权给刚创建好的git用户\n1  sudo chown -R git:git hello-hugo.git   现在服务端的git仓库已经完成了，我们回到客户端。\n进入hello-hugo目录，执行git初始化命令，将当前目录作为版本管理仓库：\n1  git init   然后将当前目录及其子目录下的所有文件纳入版本管理，并提交到git本地仓库：\n1 2  git add . git commit -m \u0026#34;Hello, hugo\u0026#34;   将当前仓库关联到我们上面创建好的远程仓库，由于已经配置了SSH公钥，可以使用ssh协议：\n1 2  git remote add origin ssh://git@your.domain:port/path/to/hello-hugo.git git push --set-upstream origin master   远程仓库地址中的git为我们上面在服务器上创建的用户，your.domai表示你自己的域名，port为服务端的ssh端口，默认22可以不写，但是不为22的时候一定要使用如上的完整路径，此时ssh://不可省略。\n我们已经完成了远程仓库和本地仓库的上下游关系关联。\n为了方便每次提交文件后将静态目录自动部署到nginx，选择用git hook在post-receive阶段将仓库中的/public整体移动到nginx指定路径。\n再切回到服务端，进入hello-hugo.git目录，可以看到该目录下有个hooks目录，里面存放的就是git支持的所有钩子，git官方在里面已经放了很多.sample结尾的示例，我们只选择使用post-receive钩子。创建post-receive文件，并使用vim进行修改，修改内容如下：\n1 2  #!/bin/bash git --work-tree=/usr/share/nginx/hello-hugo --git-dir=/path/to/hello-hugo.git checkout -f   其中--work-tree为nginx中要配置的静态资源路径，请确保对于这个路径，我们上面创建的git用户需要有写入权限，具体命令参照上面的hello-hugo.git配置；--git-dir就是服务端的hello-hugo.git仓库路径。\n在客户端我们新建一篇名为HelloHugo3.md的博客，记得把draft设置为false，然后往里面加点内容。同样在客户端进入hello-hugo目录，执行hugo命令，该命令的作用是将所有的资源生成为静态站点，并将站点存放在hello-hugo的public目录下：\n1  hugo # 生成站点   再执行git操作：\n1 2 3  git add . git commit -m \u0026#34;publish site\u0026#34; git push # 这个客户端操作将会触发服务端执行post-receive脚本   一切正常的话，服务端的/usr/share/nginx/hello-hugo目录下将会和我们的客户端工作目录一致(空目录和submodule不会被git纳入版本控制，因此data、static、themes目录不会同步到服务器)。\nnginx配置 上传SSL证书至/etc/nginx/cert目录下，nginx使用的格式为：\n your.domain_bundle.crt  your.domain.key  进入nginx配置目录/etc/nginx/conf.d，新建hello-hugo.conf文件，内容如下，端口号和路径可以根据实际情况进行修改，保证没有被占用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  server { listen 443 ssl; # https端口号，默认为443，可以自己修改  server_name your.domain; # 域名，与申请证书时候使用的域名要一致  # https相关配置  ssl_certificate cert/your.domain_bundle.crt; ssl_certificate_key cert/your.domain.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; # 这个路径就是上面我们的git hook指定的路径，再接上一个public  root /usr/share/nginx/hello-hugo/public; # 默认查找路径下的index.html  location / { index index.html index.htm; } # 默认的404页面  error_page 404 /404.html; location = /40x.html { } } server { listen 80; # 端口号可以自己修改  server_name your.domain; # 域名，与申请证书时候使用的域名要一致  # 将http重定向到https，host后面的端口号与上一个server的端口号保持一致即可  return 301 https://$host:443$request_uri; }   最后，开启nginx：\n1  nginx   客户端打开浏览器，输入你的域名(默认80端口可以不写，否则必须写)，能够成功跳转到https，地址栏能够显示小锁(小锁表示网站使用的证书是安全的)就表示已经成功了：\n留个坑 至此，Hugo从入门部署已经完成了，关于Hugo的使用细节没有覆盖到，主要是我自己也才刚开始使用，后续会慢慢积累和整理，争取把记录生活的习惯坚持下去，共勉😎。\n","permalink":"https://www.liyangjie.cn:4443/posts/hellohugo/","summary":"以前自己折腾过各种平台的博客，WordPress、Hexo、Jekyll等，但最终都没有坚持把自己的博客搭建完成，不是这里效果不好，自己折腾不出来，然后一怒之下就弃了，要么就是工作出差，回来后就忘了，总之放弃是件简单的事情。\n刚好处于工作真空期，想把一些平时学习的零碎内容整理一下，这次就坚持把这个博客完成了。这里就简单介绍下整个流程，及其中的一些坑和细节。篇幅较长，过程中可能有部分遗漏，轻喷。\n首先是这次使用的博客平台，选择Hugo的理由很简单，因为没用过它，觉得新鲜，但实际上使用流程和搭建过程其实和以前接触过的静态站点生成框架大同小异。个人电脑环境是Win10，以前安装过scoop，因此安装方法如下：\n1 2 3 4  scoop install hugo # 检查hubo是否安装完成 hugo version hugo v0.82.1-60618210 windows/amd64 BuildDate=2021-04-20T11:02:50Z VendorInfo=gohugoio   其他系统环境下安装方式见官网。\nHello Hugo 开始使用Hugo创建一个新站点hello-hugo (这个名字各位自己决定，只要当前工作目录下不存在非空的重名子目录):\n1  hugo new site hello-hugo   执行成功后，Hugo会给出温馨的提示：\n Just a few more steps and you\u0026rsquo;re ready to go:\n Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026ldquo;hugo new theme \u0026rdquo; command.","title":"Hello Hugo"}]